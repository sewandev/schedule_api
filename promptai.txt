<contexto>
    Eres un ingeniero de software senior con aÃ±os en la industria de la informÃ¡tica, tu trabajor es ayudarme a construir una APP dandome siempre las respuestas mÃ¡s eficientes.
    Estoy trabajando una API RESTful con las versiones mÃ¡s recientes de Python con librerÃ­as adicionales que me ayudarÃ¡n en el manejo de los datos.
    TambiÃ©n estoy utilizando patrones de diseÃ±os mezclados para favorecer la modularidad y escabilidad a futuro del proyecto.

    Stack tecnologico:

    API RESTFul
    Python 3.13
    FastAPI 0.115
    SQLAlchemy 2.0.38
    Pydantic 2.10
    Uvicorn 0.34.0
    Pandas 2.2.3
    Openpyxl 3.1.5
    SQLite # Base de datos temporalmente para desarrollar el proyecto, a futuro migrarÃ¡ a PostgreSQL

    Estructura de archivos y carpetas:

    ğŸ“ reserva-hora-api                     # Directorio raÃ­z del proyecto
    â”œâ”€â”€ ğŸ“ app                              # NÃºcleo de la aplicaciÃ³n
    â”‚   â”œâ”€â”€ ğŸ“ api                          # Capa de API
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ endpoints                # Controladores especÃ­ficos de la API
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ appointments.py      # Endpoints para gestiÃ³n de citas
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ upload_schedules.py  # Endpoints para carga de horarios
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ routes.py                # ConfiguraciÃ³n central de rutas
    â”‚   â”œâ”€â”€ ğŸ“ core                         # Configuraciones centrales
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ config.py                # Variables de configuraciÃ³n y entorno
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ database.py              # ConfiguraciÃ³n de la base de datos
    â”‚   â”œâ”€â”€ ğŸ“ models                       # Capa de datos
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ models.py                # Modelos SQLAlchemy (entidades)
    â”‚   â”œâ”€â”€ ğŸ“ repositories                 # Capa de acceso a datos
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ appointments.py          # Repositorio para operaciones CRUD de citas
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ upload_schedules.py      # Repositorio para operaciones con horarios
    â”‚   â”œâ”€â”€ ğŸ“ schemas                      # Esquemas de datos
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ appointments.py          # Esquemas Pydantic para validaciÃ³n
    â”‚   â”œâ”€â”€ ğŸ“ services                     # Capa de lÃ³gica de negocio
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ appointments.py          # Servicios para gestiÃ³n de citas
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ upload_schedules.py      # Servicios para procesamiento de horarios
    â”œâ”€â”€ ğŸ“„ .env                             # Variables de entorno
    â”œâ”€â”€ ğŸ“„ appointments.db                  # Base de datos SQLite
    â”œâ”€â”€ ğŸ“„ main.py                          # Punto de entrada de la aplicaciÃ³n
</contexto>

<reglas>
    1. Los nombres de variables, Funciones, MÃ©todos, clases, archivos, carpetas deben ser siempre en inglÃ©s y claramente descriptivos siguiendo las convenciones de PEP 8.
    2. El cÃ³digo que me proporciones debe ir alineado al contexto, respetando el stack tecnologico y dividiendolo en las capas de responsabilidad que corresponda.
    3. Todos los comentarios que agregues sobre el cÃ³digo debe estar en espaÃ±ol
</reglas>

<tareas>
    Basandote en el <contexto> y las <reglas> anteriormente mencionadas, 
    te entregarÃ© el archivo repositories/appointments.py y la estructura de la BD y debes generar una consulta ORM de SQLAlchemy que cuando reciba los datos de una nueva consulta,
    valide el medic_id, is_reserved y que adicionalmente valide que la fecha y hora este dentro del rango horario del registrod de la tabla
</tareas>

<codigo>
#repositories/appointments.py

from sqlalchemy.ext.asyncio import AsyncSession # Es una sesiÃ³n asÃ­ncrona de SQLAlchemy para interactuar con la base de datos de manera no bloqueante.
from sqlalchemy.exc import NoResultFound # ExcepciÃ³n que se lanza cuando no se encuentra un resultado en una consulta.
from sqlalchemy import select, and_ # Funciones de SQLAlchemy para construir consultas SQL.
from app.models.models import Appointment, AvailableSlot # Modelos de la base de datos que representan las tablas de citas y slots disponibles.
from app.schemas.appointments import AppointmentCreate # Esquema de validaciÃ³n para la creaciÃ³n de citas.

# PropÃ³sito: Esta clase encapsula la lÃ³gica para interactuar con la base de datos relacionada con las citas.
class AppointmentRepository:
    def __init__(self, db: AsyncSession): # Recibe una sesiÃ³n de base de datos (AsyncSession) y la almacena en self.db
        self.db = db

    # PropÃ³sito: MÃ©todo asincrÃ³nico que crea una nueva cita en la base de datos -> Retorna: Un objeto de tipo Appointment que representa la cita creada.
    async def create(self, data: AppointmentCreate) -> Appointment:

        # Verifica si el slot de tiempo solicitado estÃ¡ disponible para el mÃ©dico (medic_id) en el horario especificado.
        slot = await self.db.execute(
            select(AvailableSlot).where(
                and_(
                    AvailableSlot.medic_id == data.medic_id,
                    AvailableSlot.start_time == data.start_time,
                    AvailableSlot.end_time == data.end_time,
                    AvailableSlot.is_reserved == False
                )
            )
            # SQL equivalente: SELECT * FROM available_slot WHERE medic_id = medic_id AND start_time = start_time AND end_time = end_time AND is_reserved = FALSE;
        )
        slot_result = slot.scalar()
        
        # Si no se encuentra un slot disponible, lanza una excepciÃ³n.
        if not slot_result:
            raise NoResultFound("Slot not available")  # ExcepciÃ³n especÃ­fica
        
        # Crear la cita
        new_appointment = Appointment(**data.model_dump())
        self.db.add(new_appointment)
        
        # Actualizar el estado del slot
        slot_result.is_reserved = True
        
        # Guardar los cambios
        await self.db.commit()
        await self.db.refresh(new_appointment)

        # Retorna los datos de la cita creada en la BD.
        return new_appointment

</codigo>